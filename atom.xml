<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-15T13:23:38.089Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>拥有大牛梦想的小白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT - 乙 - 1045 - 快速排序</title>
    <link href="http://yoursite.com/2019/10/15/PAT---%E4%B9%99---1045---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/10/15/PAT---乙---1045---快速排序/</id>
    <published>2019-10-15T13:23:38.089Z</published>
    <updated>2019-10-15T13:23:38.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><p>著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 <em>N</em> 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？</p><p>例如给定 $N = 5$, 排列是1、3、2、4、5。则：</p><ul><li>1 的左边没有元素，右边的元素都比它大，所以它可能是主元；</li><li>尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；</li><li>尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；</li><li>类似原因，4 和 5 都可能是主元。</li></ul><p>因此，有 3 个元素可能是主元。</p><a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在第 1 行中给出一个正整数 <em>N</em>（≤105）； 第 2 行是空格分隔的 <em>N</em> 个不同的正整数，每个数不超过 109。 </p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。 </p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 2 4 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 4 5</span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Insertion Sort</span><br><span class="line">1 2 3 5 7 8 9 4 6 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Merge Sort</span><br><span class="line">1 2 3 8 4 5 7 9 0 6</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析：**"></a>分析：**</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路： </span><br><span class="line">一开始的思路是将输入的数进行排序，如果后各个数字所处的位置与排序前所处的位置是相同的，则它就是主元，但这并不是对的。如输入 3 2 4 5 1，按照这种判断，2是主元，但是2并不是主元。</span><br><span class="line">正确的做法应该是用一个数组来记录当前这个数是否是它之前所有数中的最大值，且满足上面的条件，则它就是主元。</span><br><span class="line"></span><br><span class="line">注意当没有主元时，要在下面在输出一个空白行</span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">long</span> b[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">long</span> c[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(b, b+n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(max &lt; a[i]) max = a[i];</span><br><span class="line"><span class="keyword">if</span>(max == b[i] &amp;&amp; a[i] == b[i])</span><br><span class="line">&#123;</span><br><span class="line">c[k++] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(c, c+k);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c[i];</span><br><span class="line">&#125; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：&lt;/h2&gt;&lt;p&gt;著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 &lt;em&gt;N&lt;/em&gt; 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？&lt;/p&gt;
&lt;p&gt;例如给定 $N = 5$, 排列是1、3、2、4、5。则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 的左边没有元素，右边的元素都比它大，所以它可能是主元；&lt;/li&gt;
&lt;li&gt;尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；&lt;/li&gt;
&lt;li&gt;尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；&lt;/li&gt;
&lt;li&gt;类似原因，4 和 5 都可能是主元。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，有 3 个元素可能是主元。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT乙级" scheme="http://yoursite.com/categories/PAT%E4%B9%99%E7%BA%A7/"/>
    
    
      <category term="PAT" scheme="http://yoursite.com/tags/PAT/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>PAT - 乙 - 1035 - 插入与排序</title>
    <link href="http://yoursite.com/2019/10/12/PAT---%E4%B9%99---1035---%E6%8F%92%E5%85%A5%E4%B8%8E%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/10/12/PAT---乙---1035---插入与排序/</id>
    <published>2019-10-12T09:24:06.548Z</published>
    <updated>2019-10-12T09:24:06.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><p>根据维基百科的定义：</p><p><strong>插入排序</strong>是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p><p><strong>归并排序</strong>进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。</p><p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p><a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p> 输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。 </p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p> 首先在第 1 行中输出<code>Insertion Sort</code>表示插入排序、或<code>Merge Sort</code>表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。 </p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 6 0</span><br><span class="line">1 2 3 7 8 5 9 4 6 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 0 6</span><br><span class="line">1 3 2 8 5 7 4 9 0 6</span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Insertion Sort</span><br><span class="line">1 2 3 5 7 8 9 4 6 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Merge Sort</span><br><span class="line">1 2 3 8 4 5 7 9 0 6</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析：**"></a>分析：**</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路： </span><br><span class="line">此题必须深刻理解插入排序与归并排序，除了判断前面升序，后面与原数列相同的方法，还可以去模拟插入排序，与每一次进行比对，这里要注意，测试点2应该是当你输入相同的已进行部分插入排序的数列，再进行下一次插入的时候，要看好已经有多少排好序了，比如输入2 3 4 1和2 3 4 1，要注意输出应该是1 2 3 4 。</span><br><span class="line"></span><br><span class="line">可以用sort去模拟插入排序和归并排序</span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">模拟排序：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;          <span class="comment">//当匹配到中间序列时，key置1，下次排序后输出，结束程序就行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;<span class="comment">//插入排序起始为2，结束为n，否则测试点2不通过</span></span><br><span class="line">sort(a, a + i);</span><br><span class="line"><span class="keyword">if</span> (key) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Insertion Sort"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; a[j];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (equal(a, a + n, b))  <span class="comment">//equal是一个比较数组的函数</span></span><br><span class="line">key = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mesort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;; i *= <span class="number">2</span>) &#123;   <span class="comment">//这里不给结束条件，是因为当i&gt;n时还要进行一次排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += i) &#123;</span><br><span class="line">sort(a + j, a + (j + i &lt; n ? j + i : n));  <span class="comment">//注意确定边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (key) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Merge Sort"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; a[j];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (equal(a, a + n, b))</span><br><span class="line">key = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; n)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">100</span>], a2[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a1[i];</span><br><span class="line">a2[i] = a1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">insort(a2, b);</span><br><span class="line">mesort(a1, b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：&lt;/h2&gt;&lt;p&gt;根据维基百科的定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序&lt;/strong&gt;是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;归并排序&lt;/strong&gt;进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。&lt;/p&gt;
&lt;p&gt;现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT乙级" scheme="http://yoursite.com/categories/PAT%E4%B9%99%E7%BA%A7/"/>
    
    
      <category term="PAT" scheme="http://yoursite.com/tags/PAT/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>PAT - 乙 - 1033 - 旧键盘打字</title>
    <link href="http://yoursite.com/2019/10/11/PAT---%E4%B9%99---1033---%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/11/PAT---乙---1033---旧键盘打字/</id>
    <published>2019-10-11T10:48:10.070Z</published>
    <updated>2019-10-11T10:48:10.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？</p><a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [<code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>]、数字 <code>0</code>-<code>9</code>、以及下划线 <code>_</code>（代表空格）、<code>,</code>、<code>.</code>、<code>-</code>、<code>+</code>（代表上档键）。题目保证第 2 行输入的文字串非空。</p><p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7+IE.</span><br><span class="line">7_This_is_a_test.</span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_hs_s_a_tst</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">思路： </span><br><span class="line">1.</span><br><span class="line">为了防止第一行是空的，不能用cin &gt;&gt; ,用getline(cin, ...)</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">使用cctype头文件：</span><br><span class="line">isalnum()  如果参数是字母数字，即字母或者数字，函数返回true</span><br><span class="line">isalpha()  如果参数是字母，函数返回true</span><br><span class="line">iscntrl()  如果参数是控制字符，函数返回true</span><br><span class="line">isdigit()  如果参数是数字（0－9），函数返回true</span><br><span class="line">isgraph()  如果参数是除空格之外的打印字符，函数返回true</span><br><span class="line">islower()  如果参数是小写字母，函数返回true</span><br><span class="line">isprint()  如果参数是打印字符（包括空格），函数返回true</span><br><span class="line">ispunct()  如果参数是标点符号，函数返回true</span><br><span class="line">isspace()  如果参数是标准空白字符，如空格、换行符、水平或垂直制表符，函数返回true</span><br><span class="line">isupper()  如果参数是大写字母，函数返回true</span><br><span class="line">isxdigit() 如果参数是十六进制数字，即0－9、a－f、A－F，函数返回true</span><br><span class="line"></span><br><span class="line">tolower()  如果参数是大写字符，返回其小写，否则返回该参数</span><br><span class="line">toupper()  如果参数是小写字符，返回其大写，否则返回该参数</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）</span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> bad, should;</span><br><span class="line">  getline(<span class="built_in">cin</span>, bad);  <span class="comment">//为了防止第一行是空的，不能用cin &gt;&gt; ,用getline(cin, ...)</span></span><br><span class="line">  getline(<span class="built_in">cin</span>, should);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, length = should.length(); i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bad.find(<span class="built_in">toupper</span>(should[i])) != <span class="built_in">string</span>::npos) <span class="keyword">continue</span>;    <span class="comment">//toupper()--参数小写变成大写，否则返回该参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isupper</span>(should[i]) &amp;&amp; bad.find(<span class="string">'+'</span>) != <span class="built_in">string</span>::npos) <span class="keyword">continue</span>;    <span class="comment">//判断大写字母能不能输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; should[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：&lt;/h2&gt;&lt;p&gt;旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT乙级" scheme="http://yoursite.com/categories/PAT%E4%B9%99%E7%BA%A7/"/>
    
    
      <category term="PAT" scheme="http://yoursite.com/tags/PAT/"/>
    
      <category term="cctype" scheme="http://yoursite.com/tags/cctype/"/>
    
  </entry>
  
  <entry>
    <title>PAT - 乙 - 1025 - 反转链表</title>
    <link href="http://yoursite.com/2019/10/01/PAT---%E4%B9%99---1025---%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/10/01/PAT---乙---1025---反转链表/</id>
    <published>2019-10-01T14:00:38.195Z</published>
    <updated>2019-10-01T14:00:38.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><p>给定一个常数 <em>K</em> 以及一个单链表 <em>L</em>，请编写程序将 <em>L</em> 中每 <em>K</em> 个结点反转。例如：给定 <em>L</em> 为 1→2→3→4→5→6，<em>K</em> 为 3，则输出应该为 3→2→1→6→5→4；如果 <em>K</em> 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 <em>K</em> 个元素不反转。</p><a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em> (≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code> 是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路： </span><br><span class="line">如何实现链表的反转呢？难点在于每次反转next都要改变，这就很头疼了，其实我们只需要将连接好的链表按顺序存到一个顺序表中，反转顺序，本身的“地址“不变，next刚好就是顺序表下一个元素的“地址”，只是最后一个的next为NULL（-1）；</span><br><span class="line"></span><br><span class="line">注：要考虑第一个元素的next值为-1的情况</span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> ads, data, next;</span><br><span class="line">&#125;node[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k, str, start;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Node&gt; m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; start &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;str);         <span class="comment">//输入结点数据</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m[str].data, &amp;m[str].next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">node[i] = &#123; start,m[start].data ,<span class="number">0</span> &#125;;<span class="comment">//通过map直接索引start将链表按顺序转到node数组里面</span></span><br><span class="line">start = m[start].next;</span><br><span class="line"><span class="keyword">if</span> (start == <span class="number">-1</span>)     <span class="comment">//当start被赋值为-1的时候，链表就结束了，更新n的值，测试点6</span></span><br><span class="line">n = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % k == <span class="number">0</span>)</span><br><span class="line">reverse(node + i + <span class="number">1</span> - k, node + i + <span class="number">1</span>);   <span class="comment">//反转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;   <span class="comment">//输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, node[i].ads, node[i].data);</span><br><span class="line"><span class="keyword">if</span> (i != n - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, node[i + <span class="number">1</span>].ads);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1"</span>);  <span class="comment">//最后一个结点next为-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：&lt;/h2&gt;&lt;p&gt;给定一个常数 &lt;em&gt;K&lt;/em&gt; 以及一个单链表 &lt;em&gt;L&lt;/em&gt;，请编写程序将 &lt;em&gt;L&lt;/em&gt; 中每 &lt;em&gt;K&lt;/em&gt; 个结点反转。例如：给定 &lt;em&gt;L&lt;/em&gt; 为 1→2→3→4→5→6，&lt;em&gt;K&lt;/em&gt; 为 3，则输出应该为 3→2→1→6→5→4；如果 &lt;em&gt;K&lt;/em&gt; 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 &lt;em&gt;K&lt;/em&gt; 个元素不反转。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT乙级" scheme="http://yoursite.com/categories/PAT%E4%B9%99%E7%BA%A7/"/>
    
    
      <category term="PAT" scheme="http://yoursite.com/tags/PAT/"/>
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>PAT - 乙 - 1017 - A除以B</title>
    <link href="http://yoursite.com/2019/09/23/PAT---%E4%B9%99---1017---A%E9%99%A4%E4%BB%A5B/"/>
    <id>http://yoursite.com/2019/09/23/PAT---乙---1017---A除以B/</id>
    <published>2019-09-23T13:34:06.014Z</published>
    <updated>2019-09-30T11:59:39.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><p>本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。</p><a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在一行中依次给出 A 和 B，中间以 1 空格分隔。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中依次输出 Q 和 R，中间以 1 空格分隔。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123456789050987654321 7</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17636684150141093474 3</span><br><span class="line">0 6</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>一看数据范围就知道这是一个高精度的运算，不过除数只是1位数的正整数，难度就降低了很多，只需要<strong>模拟除法运算</strong>的规则即可。</p><p>不过在编写程序中需要考虑到<strong>被除数小于除数的情况</strong></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">int</span> len = a.length();</span><br><span class="line"><span class="keyword">int</span> tmp, flag;</span><br><span class="line">tmp = <span class="number">0</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = (a[i] - <span class="string">'0'</span>) + tmp * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(tmp &gt;= b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tmp / b;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = tmp % b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>;<span class="comment">//被除数小于除数的情况</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：&lt;/h2&gt;&lt;p&gt;本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT乙级" scheme="http://yoursite.com/categories/PAT%E4%B9%99%E7%BA%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>PAT - 乙 - 1008 - 数组元素循环右移问题</title>
    <link href="http://yoursite.com/2019/09/21/PAT---%E4%B9%99---1008---%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/09/21/PAT---乙---1008---数组元素循环右移问题/</id>
    <published>2019-09-21T08:38:14.827Z</published>
    <updated>2019-09-30T11:59:30.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A<font size="1">0</font>A<font size="1">1</font>⋯A<font size="1">N-1</font>）变换为（A<font size="1">N-M</font>⋯A<font size="1">N-1</font>A<font size="1">0</font>A<font size="1">1</font>⋯A<font size="1">N-M-1</font>）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个输入包含一个测试用例，第1行输入<em>N</em>（1≤<em>N</em>≤100）和<em>M</em>（≥0）；第2行输入<em>N</em>个整数，之间用空格分隔。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。在一行中输出循环右移<em>M</em>位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 2</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 6 1 2 3 4</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p><strong>首先需要注意题目并没有给定 M 的最大值，因此不能直接认为M &lt; N，而需要在读入 N 和 M 后令</strong><br><strong>M = M % N</strong>，这样就可以保证 M &lt; N,使后面的操作更加简便。这样做的依据是对一个长度为 N 的序列，右移 N 位之后的序列和当前序列是相同的。</p><p><strong>方法一：循环法</strong><br>以下列输入样例为例<br>6 2<br>1 2 3 4 5 6<br>首先将 N - M 位置的数换到第一个位置，然后 N - M - 1 到 1 位置的数都往后移；<br>接着将 N - M + 1 位置的数换到第二个位置，然后 N - M 到 2 位置的数都往后移；<br>…….<br>直到完成。</p><p><strong>方法二：翻转法</strong></p><p>这是一种很有技巧性的解法，经过三次翻转即可得到结果。我们设数组长度为N，右移位数为M。</p><ol><li><p>首先将区间（以0位首位）， 【N- M，N - 1】进行翻转。</p><p>2.再将区间【0，（N - M - 1）】进行对称翻转。</p><p>3.最后将整个区间进行对称翻转。</p></li></ol><p>比如：N = 8， M = 3，数组为1 2 3 4 5 6 7 8</p><p>​        第一步，将 6 7 8三个数进行翻转， 数组变为1 2 3 4 5 8 7 6</p><p>​        第二步，将1 2 3 4 5 五个数进行对称翻转，数组变为 5 4 3 2 1 8 7 6</p><p>​        第三步，将整个数组进行对称翻转，数组变为6 7 8 1 2 3 4 5</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">循环法：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">m = m % n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">k = a[n-i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = n-i; j &gt; m-i; j--)</span><br><span class="line">&#123;</span><br><span class="line">a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">a[m-i] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">翻转法：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">int</span> mid = (l + h) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mid; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = a[i];</span><br><span class="line">a[i] = a[l + h - i];</span><br><span class="line">a[l + h - i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">m = m % n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">reverse(a,n-m,n<span class="number">-1</span>);</span><br><span class="line">reverse(a,<span class="number">0</span>,n-m<span class="number">-1</span>);</span><br><span class="line">reverse(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：&lt;/h2&gt;&lt;p&gt;一个数组A中存有N（&amp;gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A&lt;font size=&quot;1&quot;&gt;0&lt;/font&gt;A&lt;font size=&quot;1&quot;&gt;1&lt;/font&gt;⋯A&lt;font size=&quot;1&quot;&gt;N-1&lt;/font&gt;）变换为（A&lt;font size=&quot;1&quot;&gt;N-M&lt;/font&gt;⋯A&lt;font size=&quot;1&quot;&gt;N-1&lt;/font&gt;A&lt;font size=&quot;1&quot;&gt;0&lt;/font&gt;A&lt;font size=&quot;1&quot;&gt;1&lt;/font&gt;⋯A&lt;font size=&quot;1&quot;&gt;N-M-1&lt;/font&gt;）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT乙级" scheme="http://yoursite.com/categories/PAT%E4%B9%99%E7%BA%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>PAT - 乙 - 1003 - 我要通过</title>
    <link href="http://yoursite.com/2019/09/20/PAT-%E4%B9%99-1003/"/>
    <id>http://yoursite.com/2019/09/20/PAT-乙-1003/</id>
    <published>2019-09-20T12:54:11.228Z</published>
    <updated>2019-10-01T13:50:03.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。</p><p>得到“<strong>答案正确</strong>”的条件是：</p><ol><li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li><li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li><li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</li></ol><p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</p><a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (n&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">PAT</span><br><span class="line">PAAT</span><br><span class="line">AAPATAA</span><br><span class="line">AAPAATAAAA</span><br><span class="line">xPATx</span><br><span class="line">PT</span><br><span class="line">Whatever</span><br><span class="line">APAAATAA</span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不要想当然，题目的意思是</span><br><span class="line">PAT           p前面有0个A,pt之间有1个A，T 后面有0个A,  0*1=0   正确</span><br><span class="line">PAAT          p前面有0个A,pt之间有2个A，T 后面有0个A,  0*2=0   正确</span><br><span class="line">AAPATAA       p前面有2个A,pt之间有1个A，T 后面有2个A,  2*1=2   正确</span><br><span class="line">AAPAATAAAA    p前面有2个A,pt之间有2个A，T 后面有2个A,  2*2=4   正确</span><br><span class="line">总结：只能有一个P和T，前面A的个数 * 中间A的个数 = 后面A的个数</span><br><span class="line">可以用三个变量，cnt1，cnt2，cnt3将每个部分的A的个数记录下来，最后判断cnt1 * cnt2是否等于cnt3</span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTrue</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, cnt1, cnt2, cnt3;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">"PAT"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">"PT"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">cnt1 = cnt2 = cnt3 = i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s[i] == <span class="string">'A'</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt1++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'P'</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(s[i] == <span class="string">'A'</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt2++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'T'</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(s[i] == <span class="string">'A'</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt3++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt3 == cnt1 * cnt2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">flag = isTrue(s);</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：&lt;/h2&gt;&lt;p&gt;“&lt;strong&gt;答案正确&lt;/strong&gt;”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“&lt;strong&gt;答案正确&lt;/strong&gt;”大派送 —— 只要读入的字符串满足下列条件，系统就输出“&lt;strong&gt;答案正确&lt;/strong&gt;”，否则输出“&lt;strong&gt;答案错误&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;得到“&lt;strong&gt;答案正确&lt;/strong&gt;”的条件是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符串中必须仅有 &lt;code&gt;P&lt;/code&gt;、 &lt;code&gt;A&lt;/code&gt;、 &lt;code&gt;T&lt;/code&gt;这三种字符，不可以包含其它字符；&lt;/li&gt;
&lt;li&gt;任意形如 &lt;code&gt;xPATx&lt;/code&gt; 的字符串都可以获得“&lt;strong&gt;答案正确&lt;/strong&gt;”，其中 &lt;code&gt;x&lt;/code&gt; 或者是空字符串，或者是仅由字母 &lt;code&gt;A&lt;/code&gt; 组成的字符串；&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;aPbTc&lt;/code&gt; 是正确的，那么 &lt;code&gt;aPbATca&lt;/code&gt; 也是正确的，其中 &lt;code&gt;a&lt;/code&gt;、 &lt;code&gt;b&lt;/code&gt;、 &lt;code&gt;c&lt;/code&gt; 均或者是空字符串，或者是仅由字母 &lt;code&gt;A&lt;/code&gt; 组成的字符串。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“&lt;strong&gt;答案正确&lt;/strong&gt;”的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT乙级" scheme="http://yoursite.com/categories/PAT%E4%B9%99%E7%BA%A7/"/>
    
    
      <category term="PAT" scheme="http://yoursite.com/tags/PAT/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
