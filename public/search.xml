<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT - 乙 - 1035 - 插入与排序]]></title>
    <url>%2F2019%2F10%2F12%2FPAT---%E4%B9%99---1035---%E6%8F%92%E5%85%A5%E4%B8%8E%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[问题描述：根据维基百科的定义： 插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。 归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。 现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？ 输入格式： 输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。 输出格式： 首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。 输入样例：123103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0 123103 1 2 8 7 5 9 4 0 61 3 2 8 5 7 4 9 0 6 输出样例：12Insertion Sort1 2 3 5 7 8 9 4 6 0 12Merge Sort1 2 3 8 4 5 7 9 0 6 分析：**1234思路： 此题必须深刻理解插入排序与归并排序，除了判断前面升序，后面与原数列相同的方法，还可以去模拟插入排序，与每一次进行比对，这里要注意，测试点2应该是当你输入相同的已进行部分插入排序的数列，再进行下一次插入的时候，要看好已经有多少排好序了，比如输入2 3 4 1和2 3 4 1，要注意输出应该是1 2 3 4 。可以用sort去模拟插入排序和归并排序 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253模拟排序：#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n;void insort(int a[], int b[]) &#123; int key = 0; //当匹配到中间序列时，key置1，下次排序后输出，结束程序就行 for (int i = 2; i &lt;= n; i++) &#123; //插入排序起始为2，结束为n，否则测试点2不通过 sort(a, a + i); if (key) &#123; cout &lt;&lt; "Insertion Sort" &lt;&lt; endl; cout &lt;&lt; a[0]; for (int j = 1; j &lt; n; j++) cout &lt;&lt; " " &lt;&lt; a[j]; return; &#125; if (equal(a, a + n, b)) //equal是一个比较数组的函数 key = 1; &#125;&#125;void mesort(int a[], int b[]) &#123; int key = 0; for (int i = 2;; i *= 2) &#123; //这里不给结束条件，是因为当i&gt;n时还要进行一次排序 for (int j = 0; j &lt; n; j += i) &#123; sort(a + j, a + (j + i &lt; n ? j + i : n)); //注意确定边界 &#125; if (key) &#123; cout &lt;&lt; "Merge Sort" &lt;&lt; endl; cout &lt;&lt; a[0]; for (int j = 1; j &lt; n; j++) cout &lt;&lt; " " &lt;&lt; a[j]; return; &#125; if (equal(a, a + n, b)) key = 1; if (i &gt; n) break; &#125;&#125;int main() &#123; cin &gt;&gt; n; int a1[100], a2[100], b[100]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a1[i]; a2[i] = a1[i]; &#125; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; insort(a2, b); mesort(a1, b); return 0;&#125;]]></content>
      <categories>
        <category>PAT乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT - 乙 - 1033 - 旧键盘打字]]></title>
    <url>%2F2019%2F10%2F11%2FPAT---%E4%B9%99---1033---%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97%2F</url>
    <content type="text"><![CDATA[问题描述：旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式：输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。 注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式：在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例：127+IE.7_This_is_a_test. 输出样例：1_hs_s_a_tst 分析：1234567891011121314151617181920212223思路： 1.为了防止第一行是空的，不能用cin &gt;&gt; ,用getline(cin, ...)2.使用cctype头文件：isalnum() 如果参数是字母数字，即字母或者数字，函数返回trueisalpha() 如果参数是字母，函数返回trueiscntrl() 如果参数是控制字符，函数返回trueisdigit() 如果参数是数字（0－9），函数返回trueisgraph() 如果参数是除空格之外的打印字符，函数返回trueislower() 如果参数是小写字母，函数返回trueisprint() 如果参数是打印字符（包括空格），函数返回trueispunct() 如果参数是标点符号，函数返回trueisspace() 如果参数是标准空白字符，如空格、换行符、水平或垂直制表符，函数返回trueisupper() 如果参数是大写字母，函数返回trueisxdigit() 如果参数是十六进制数字，即0－9、a－f、A－F，函数返回truetolower() 如果参数是大写字符，返回其小写，否则返回该参数toupper() 如果参数是小写字符，返回其大写，否则返回该参数3.string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数） 代码：123456789101112131415#include &lt;iostream&gt; #include &lt;cctype&gt;using namespace std;int main() &#123; string bad, should; getline(cin, bad); //为了防止第一行是空的，不能用cin &gt;&gt; ,用getline(cin, ...) getline(cin, should); for (int i = 0, length = should.length(); i &lt; length; i++) &#123; if (bad.find(toupper(should[i])) != string::npos) continue; //toupper()--参数小写变成大写，否则返回该参数 if (isupper(should[i]) &amp;&amp; bad.find('+') != string::npos) continue; //判断大写字母能不能输出 cout &lt;&lt; should[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>cctype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT - 乙 - 1025 - 反转链表]]></title>
    <url>%2F2019%2F10%2F01%2FPAT---%E4%B9%99---1025---%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述：给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。 输入格式：每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤105)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。 接下来有 N 行，每行格式为： 1Address Data Next 其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。 输出格式：对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 输入样例：123456700100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 输出样例：12345600000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 分析：1234思路： 如何实现链表的反转呢？难点在于每次反转next都要改变，这就很头疼了，其实我们只需要将连接好的链表按顺序存到一个顺序表中，反转顺序，本身的“地址“不变，next刚好就是顺序表下一个元素的“地址”，只是最后一个的next为NULL（-1）；注：要考虑第一个元素的next值为-1的情况 代码：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;struct Node &#123; int ads, data, next;&#125;node[100000];int main() &#123; int n, k, str, start; map&lt;int, Node&gt; m; cin &gt;&gt; start &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;str); //输入结点数据 scanf("%d %d", &amp;m[str].data, &amp;m[str].next); &#125; for (int i = 0; i &lt; n; i++) &#123; node[i] = &#123; start,m[start].data ,0 &#125;;//通过map直接索引start将链表按顺序转到node数组里面 start = m[start].next; if (start == -1) //当start被赋值为-1的时候，链表就结束了，更新n的值，测试点6 n = i + 1; if ((i + 1) % k == 0) reverse(node + i + 1 - k, node + i + 1); //反转 &#125; for (int i = 0; i &lt; n; i++) &#123; //输出 printf("%05d %d ", node[i].ads, node[i].data); if (i != n - 1) printf("%05d\n", node[i + 1].ads); else printf("-1"); //最后一个结点next为-1 &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT - 乙 - 1017 - A除以B]]></title>
    <url>%2F2019%2F09%2F23%2FPAT---%E4%B9%99---1017---A%E9%99%A4%E4%BB%A5B%2F</url>
    <content type="text"><![CDATA[问题描述：本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 输入样例：12123456789050987654321 76 7 输出样例：1217636684150141093474 30 6 分析：一看数据范围就知道这是一个高精度的运算，不过除数只是1位数的正整数，难度就降低了很多，只需要模拟除法运算的规则即可。 不过在编写程序中需要考虑到被除数小于除数的情况 代码：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string a; int b; cin &gt;&gt; a &gt;&gt; b; int len = a.length(); int tmp, flag; tmp = 0; flag = 0; for(int i = 0; i &lt; len; i++) &#123; tmp = (a[i] - '0') + tmp * 10; if(tmp &gt;= b) &#123; cout &lt;&lt; tmp / b; flag = 1; &#125; else if(flag == 1) &#123; cout&lt;&lt;"0"; &#125; tmp = tmp % b; &#125; if(flag == 0) cout&lt;&lt;"0";//被除数小于除数的情况 cout&lt;&lt;" "&lt;&lt;tmp; return 0;&#125;]]></content>
      <categories>
        <category>PAT乙级</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT - 乙 - 1008 - 数组元素循环右移问题]]></title>
    <url>%2F2019%2F09%2F21%2FPAT---%E4%B9%99---1008---%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述：一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0A1⋯AN-1）变换为（AN-M⋯AN-1A0A1⋯AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式：每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例：126 21 2 3 4 5 6 输出样例：15 6 1 2 3 4 分析：首先需要注意题目并没有给定 M 的最大值，因此不能直接认为M &lt; N，而需要在读入 N 和 M 后令M = M % N，这样就可以保证 M &lt; N,使后面的操作更加简便。这样做的依据是对一个长度为 N 的序列，右移 N 位之后的序列和当前序列是相同的。 方法一：循环法以下列输入样例为例6 21 2 3 4 5 6首先将 N - M 位置的数换到第一个位置，然后 N - M - 1 到 1 位置的数都往后移；接着将 N - M + 1 位置的数换到第二个位置，然后 N - M 到 2 位置的数都往后移；…….直到完成。 方法二：翻转法 这是一种很有技巧性的解法，经过三次翻转即可得到结果。我们设数组长度为N，右移位数为M。 首先将区间（以0位首位）， 【N- M，N - 1】进行翻转。 2.再将区间【0，（N - M - 1）】进行对称翻转。 3.最后将整个区间进行对称翻转。 比如：N = 8， M = 3，数组为1 2 3 4 5 6 7 8 ​ 第一步，将 6 7 8三个数进行翻转， 数组变为1 2 3 4 5 8 7 6 ​ 第二步，将1 2 3 4 5 五个数进行对称翻转，数组变为 5 4 3 2 1 8 7 6 ​ 第三步，将整个数组进行对称翻转，数组变为6 7 8 1 2 3 4 5 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273循环法：#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n, m; int a[100]; cin &gt;&gt; n &gt;&gt; m; m = m % n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; int k; for(int i = m; i &gt;= 1; i--) &#123; k = a[n-i]; for(int j = n-i; j &gt; m-i; j--) &#123; a[j] = a[j-1]; &#125; a[m-i] = k; &#125; for(int i = 0; i &lt; n; i++) &#123; if(i &gt; 0) cout&lt;&lt;" "; cout &lt;&lt; a[i]; &#125; return 0;&#125;翻转法：#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void reverse(int a[],int l,int h)&#123; int tmp; int mid = (l + h) / 2; for(int i = l; i &lt;= mid; i++) &#123; tmp = a[i]; a[i] = a[l + h - i]; a[l + h - i] = tmp; &#125;&#125;int main()&#123; int n, m; int a[100]; cin &gt;&gt; n &gt;&gt; m; m = m % n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; reverse(a,n-m,n-1); reverse(a,0,n-m-1); reverse(a,0,n-1); for(int i = 0; i &lt; n; i++) &#123; if(i &gt; 0) cout&lt;&lt;" "; cout &lt;&lt; a[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT乙级</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT - 乙 - 1003 - 我要通过]]></title>
    <url>%2F2019%2F09%2F20%2FPAT-%E4%B9%99-1003%2F</url>
    <content type="text"><![CDATA[问题描述：“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式：每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (n&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 输入样例：1234567898PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA 输出样例：12345678YESYESYESYESNONONONO 分析：1234567不要想当然，题目的意思是PAT p前面有0个A,pt之间有1个A，T 后面有0个A, 0*1=0 正确PAAT p前面有0个A,pt之间有2个A，T 后面有0个A, 0*2=0 正确AAPATAA p前面有2个A,pt之间有1个A，T 后面有2个A, 2*1=2 正确AAPAATAAAA p前面有2个A,pt之间有2个A，T 后面有2个A, 2*2=4 正确总结：只能有一个P和T，前面A的个数 * 中间A的个数 = 后面A的个数可以用三个变量，cnt1，cnt2，cnt3将每个部分的A的个数记录下来，最后判断cnt1 * cnt2是否等于cnt3 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int isTrue(string s)&#123; int i, cnt1, cnt2, cnt3; if(s == "PAT") return 1; if(s == "PT") return 0; cnt1 = cnt2 = cnt3 = i = 0; while(s[i] == 'A') &#123; cnt1++; i++; &#125; if(s[i] == 'P') &#123; i++; &#125; else &#123; return 0; &#125; while(s[i] == 'A') &#123; cnt2++; i++; &#125; if(s[i] == 'T') &#123; i++; &#125; else &#123; return 0; &#125; while(s[i] == 'A') &#123; cnt3++; i++; &#125; if(cnt3 == cnt1 * cnt2) return 1; else return 0;&#125;int main()&#123; int n; string s; cin &gt;&gt; n; int flag; while(n--) &#123; cin &gt;&gt; s; flag = isTrue(s); if(flag == 1) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
